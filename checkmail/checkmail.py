#!/usr/bin/python
# -*- coding: utf-8 -*-
# Autor: Israel Rios
# Created: 23-jan-2009
import os
import sys
#from getpass import getpass
import wx
import string
import time
import email.header
from imaplib import IMAP4
import subprocess

    
###############################################
# Inicialização

if 'http_proxy' in os.environ:
    del os.environ['http_proxy'] #não utiliza proxy para acessar a página
    
# Os campos do formulário
fields = {}
#print "Username: ",
#fields['uid'] = sys.stdin.readline().strip()
#fields['pwd'] = getpass("Password for %s: " % fields['uid'])

###########################################################
# Verifica se existem novas mensagens de email que se encaixam nos filtros
def checkNewMail():
    try:
        subjects = []
        imap = IMAP4('expressomx.pr.gov.br', 143)

        imap.login(fields['uid'], fields['pwd'])
        try:
            imap.select(readonly=True)
            #filtros para o lixo
            criteria = '(UNSEEN NOT FROM "divulgacao@celepar.pr.gov.br"' + \
                ' NOT FROM "funceladm@celepar.pr.gov.br"' + \
                ' NOT FROM "celtrans@celtrans.pr.gov.br"' + \
                ' NOT FROM "Atos Administrativos")'
            typ, msgnums = imap.search(None, criteria)
            
            parseError(typ, msgnums)

            if len(msgnums) > 0 and len(msgnums[0].strip()) > 0:
                typ, msgs = imap.fetch( msgnums[0].replace(' ', ',') , 
                                        '(BODY[HEADER.FIELDS (SUBJECT)])')
                #print msgs
                parseError(typ, msgs)
                for m in msgs:
                    if m != ')':
                        dec = email.header.decode_header(m[1].strip('Subject:').strip())[0]
                        if dec[1] != None:
                            subject = dec[0].decode(dec[1])
                        else:
                            subject = dec[0]
                        subjects.append(subject)

        finally:
            imap.close()
            imap.logout()

        return subjects

    except Exception, e:
        wx.MessageBox(u"It was not possible to check your mail box. Error:\n\n" +
                      str(e), "Error", wx.ICON_ERROR)
        sys.exit(1)

def parseError(typ, msgnums):
    if typ != 'OK':
        if len(msgnums) > 0:
            raise Exception(msgnums[0])
        else:
            raise Exception('Bad response.')


######################################################################
# Parte gráfica

##
# Classe que representa o ícone na barra de tarefas
#
class CheckMailTaskIcon(wx.TaskBarIcon):

    def __init__(self):
        wx.TaskBarIcon.__init__(self)
        self.MENU_EXIT = wx.NewId()
        self.MENU_REFRESH = wx.NewId()
        self.Bind(wx.EVT_MENU, self.onMenuExit, id = self.MENU_EXIT)
        self.Bind(wx.EVT_MENU, self.onMenuRefresh, id = self.MENU_REFRESH)
        self.Bind(wx.EVT_TASKBAR_LEFT_DCLICK, self.onLeftDClick)

    def CreatePopupMenu(self):
        menu = wx.Menu()
        mi = wx.MenuItem(menu, self.MENU_EXIT, "&Quit")
        mi.SetBitmap(wx.ArtProvider.GetBitmap('gtk-quit', wx.ART_MENU))
        menu.AppendItem(mi)
        #menu.Append(self.MENU_EXIT, "&Quit")
        mi = wx.MenuItem(menu, self.MENU_REFRESH, "&Refresh")
        mi.SetBitmap(wx.ArtProvider.GetBitmap('gtk-refresh', wx.ART_MENU))
        menu.AppendItem(mi)
        #menu.Append(self.MENU_REFRESH, "&Refresh")
        return menu

    def onMenuExit(self, event):
        app.ExitMainLoop()

    def onMenuRefresh(self, event):
        app.forceRefresh()

    def onLeftDClick(self, event):
        subprocess.Popen('icedove')

    ##
    # Cria e mostra o ícone com o status do email
    #
    def setIconBar(self, hasmail, tip):
        if hasmail:
            iconname = 'mail-unread.png'
        else:
            iconname = 'mail-read.png'
        #icon = wx.ArtProvider.GetIcon(iconname, wx.ART_TOOLBAR, (22,22))
        iconname = os.path.join(app.dir, iconname)
        icon = wx.Icon(iconname, wx.BITMAP_TYPE_PNG)
        #wasinst = self.IsIconInstalled()
        self.SetIcon(icon, tip)
        #Correção de misterioso bug que deixa o ícone desenhado pela metade de vez em quando
        #if not wasinst:
        #    self.RemoveIcon()
        #    self.SetIcon(icon, tip)

# generated by wxGlade 0.4.1 on Mon Jan 26 10:42:01 2009
class LoginWindow(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: LoginWindow.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.panel = wx.Panel(self, -1)
        self.stusername = wx.StaticText(self.panel, -1, "Username:")
        self.edusername = wx.TextCtrl(self.panel, -1, "")
        self.stpassword = wx.StaticText(self.panel, -1, "Password:")
        self.edpassword = wx.TextCtrl(self.panel, -1, "", style=wx.TE_PASSWORD)
        self.btncancel = wx.Button(self.panel, -1, "&Cancel")
        self.btnlogin = wx.Button(self.panel, -1, "&Login")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.onCancel, self.btncancel)
        self.Bind(wx.EVT_BUTTON, self.onLogin, self.btnlogin)
        # end wxGlade
        self.edusername.SetFocus()

    def __set_properties(self):
        # begin wxGlade: LoginWindow.__set_properties
        self.SetTitle("Login - CheckMail")
        self.btnlogin.SetDefault()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: LoginWindow.__do_layout
        defaultsizer = wx.BoxSizer(wx.HORIZONTAL)
        vbox = wx.BoxSizer(wx.VERTICAL)
        hboxbuttons = wx.BoxSizer(wx.HORIZONTAL)
        gridcontrols = wx.FlexGridSizer(2, 2, 10, 5)
        gridcontrols.Add(self.stusername, 0, wx.ALIGN_CENTER_VERTICAL|wx.ADJUST_MINSIZE, 0)
        gridcontrols.Add(self.edusername, 0, wx.EXPAND|wx.ADJUST_MINSIZE, 0)
        gridcontrols.Add(self.stpassword, 0, wx.ALIGN_CENTER_VERTICAL|wx.ADJUST_MINSIZE, 0)
        gridcontrols.Add(self.edpassword, 0, wx.EXPAND|wx.ADJUST_MINSIZE, 0)
        gridcontrols.AddGrowableCol(1)
        vbox.Add(gridcontrols, 1, wx.ALL|wx.EXPAND, 8)
        hboxbuttons.Add(self.btncancel, 0, wx.RIGHT|wx.ALIGN_RIGHT|wx.ALIGN_BOTTOM|wx.ADJUST_MINSIZE, 30)
        hboxbuttons.Add(self.btnlogin, 0, wx.ALIGN_RIGHT|wx.ALIGN_BOTTOM|wx.ADJUST_MINSIZE, 0)
        vbox.Add(hboxbuttons, 0, wx.ALL|wx.ALIGN_RIGHT, 8)
        self.panel.SetAutoLayout(True)
        self.panel.SetSizer(vbox)
        vbox.Fit(self.panel)
        vbox.SetSizeHints(self.panel)
        defaultsizer.Add(self.panel, 1, wx.EXPAND, 0)
        self.SetAutoLayout(True)
        self.SetSizer(defaultsizer)
        defaultsizer.Fit(self)
        defaultsizer.SetSizeHints(self)
        self.Layout()
        self.Centre()
        # end wxGlade

    def onCancel(self, event): # wxGlade: LoginWindow.<event_handler>
        self.Close()
        app.ExitMainLoop()

    def onLogin(self, event): # wxGlade: LoginWindow.<event_handler>
        global fields
        username = self.edusername.GetValue()
        password = self.edpassword.GetValue()
        if len(username.strip()) == 0 or len(password.strip()) == 0:
            wx.MessageBox(u"Username and password are required.",
                          "CheckMail", wx.ICON_INFORMATION)
            event.Skip()
            return
        fields['uid'] = username
        fields['pwd'] = password
        self.Close()
        app.createTaskBarIcon()

# end of class LoginWindow


#
# The main application wx.App class
#
class CheckMailApp(wx.App):
    def OnInit(self):
        self.dir = os.path.dirname(sys.argv[0])
        self.refreshMinutes = 3
        framelogin = LoginWindow(None, -1, "")
        framelogin.Show()
        self.SetExitOnFrameDelete(False)
        return True

    # Cria o ícone, o timer e aciona o primeiro refresh
    def createTaskBarIcon(self):
        self.tbicon = CheckMailTaskIcon()
        self.setIconTimer()
        self.refresh(None)

    ##
    # Configura o timer
    #
    def setIconTimer(self):
        self.ID_ICON_TIMER = wx.NewId()
        self.icon_timer = wx.Timer(self, self.ID_ICON_TIMER)
        wx.EVT_TIMER(self, self.ID_ICON_TIMER, self.refresh)
        self.icon_timer.Start(1000*60*self.refreshMinutes)

    #Reinicia o timer e faz o refresh
    def forceRefresh(self):
        self.icon_timer.Start(1000*60*self.refreshMinutes)
        self.refresh(None)

    ##
    # Atualiza o ícone com o status do email
    #
    def refresh(self, event):
        subjects = checkNewMail()
        hasmail = len(subjects) > 0
        if hasmail:
            tip = '*' + '\n* '.join(subjects)
        else:
            tip = 'No new email'
        self.tbicon.setIconBar(hasmail, tip)

app = CheckMailApp(0)
app.MainLoop()
